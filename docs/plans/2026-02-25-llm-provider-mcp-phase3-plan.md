# План дій: Фаза 3 - Внутрішній MCP Клієнт (LLM Provider MCP) 

**Проєкт**: LLM Provider MCP (Grynya-Agent-Box)
**Дата створення**: 2026-02-25
**Зв'язана специфікація**: [llm_provider_mcp.md](../specs/llm_provider_mcp.md)
**Пов'язана сесія у FalkorDB**: `session_2026-02-25_14-33-23`

## Контекст
Ми успішно завершили Фазу 1 (контейнеризація) та Фазу 2 (інтеграція LLM, перехід на SSE, підключення OAuth2 для Gemini). Сервер стабільно працює у Docker контейнері.

Наступний крок (Фаза 3) полягає в тому, щоб зробити цей MCP-сервер також **MCP-клієнтом**. Мета: щоб модель (Gemini/OpenAI) під час виконання `run_agent_task` могла самостійно виявляти та викликати інструменти з інших локальних MCP-серверів (наприклад, FalkorDB).

## Проблематика (R&D)
FastMCP запускає свій серверний `async` цикл подій (event loop). Для підключення до іншого MCP-сервера (по SSE або stdio) потрібен клієнтський об'єкт, який теж вимагає асинхронного контексту. 
Змішування цих контекстів всередині синхронного або асинхронного обробника `@mcp.tool()` може викликати помилки на кшталт `RuntimeError: This event loop is already running`.

## Ключові файли проєкту
*   **Сервер**: `c:\Antigarvity_workspace\llm_provider_mcp\src\server.py`
    *Тут потрібно буде додати логіку MCP-клієнта, можливо винести її в окремий модуль `client.py`.*
*   **Інфраструктура**: `c:\Antigarvity_workspace\falkordb-service\docker-compose.yml`
    *Ключ для мережевого конекту: контейнеру `llm-provider-mcp` доведеться звертатися до контейнера `grynya-mcp-server` (FalkorDB).*
*   **Залежності**: `c:\Antigarvity_workspace\llm_provider_mcp\requirements.txt`
    *Потрібно переконатися, що SDK підтримує клієнтську частину (mcp пакети).*

## Завдання для наступної сесії

1.  **Створення Proof of Concept (PoC) для MCP-Клієнта:**
    *   Створити мінімальний `test_client.py` поза основним сервером.
    *   Спробувати підключитися (через SSE або stdio) до вже працюючого на порту `8000` `grynya-mcp-server`.
    *   Витягнути список інструментів з FalkorDB.

2.  **Інтеграція Клієнта в `run_agent_task`:**
    *   Реалізувати механізм створення тимчасової клієнтської сесії (або використання постійного пулу підключень) всередині тулзи.
    *   Передача виявлених інструментів в конфігурацію `gemini` (`types.GenerateContentConfig(tools=...)`) та `openai` (`tools=[...]`).
    *   Обробка `tool_calls` від моделі (виклик інструменту до FalkorDB та повернення результату моделі).

3.  **Вирішення проблеми Event Loop:**
    *   Якщо виникнуть проблеми з асинхронністю, розглянути використання `asyncio.create_task` або запуску клієнта в окремому `Thread` (за допомогою `asyncio.run_coroutine_threadsafe`).
    *   Дослідити пакет `mcp.client` та клас `ClientSession`.

## Важливі вузли у графі FalkorDB
*   `Session`: `session_2026-02-25_14-33-23` (містить усю історію переходу на SSE та OAuth).
*   `Entity`: `ent_fastmcp`, `ent_google_oauth2`, `ent_sse`.
*   `Analysis`: `anl_session_2026-02-25_14-33-23`, `anl_session_2026-02-25_14-49-04`, `anl_session_2026-02-25_14-59-58`.

---
*План згенеровано автоматично перед закриттям сесії.*
