---
name: graphrag-system-design
description: Проєктування та оптимізація систем GraphRAG (включно зі стеком Grynya), проєктування схем, шаблонів для доменно-специфічного контексту та стратегій інтеграції.
---

# Проєктування Систем GraphRAG (GraphRAG System Design)

Використовуй цю навичку при розробці комплексних GraphRAG рішень, проєктуванні схем Knowledge Graph, виборі технологічного стеку або адаптації графів для конкретних доменів. Для проєкту Grynya ця навичка задає ключові компоненти та патерни архітектури.

## Важливі ресурси
- [Технологічний Стек Grynya](resources/grynya-stack.md): Деталі стеку (FalkorDB + MCP Bridge + Docker) та обмеження.
- [Патерни Графа Grynya](resources/grynya-patterns.md): Основні патерни: Temporal Chain, Node Triad, Entity Linking, Self-Evolving Graph.
- *Загальні ресурси стеку*: `resources/references/technology-stacks.md`
- *Загальні доменні патерни*: `resources/references/domain-patterns.md`

## Робочий процес (Workflow)

**КРОК 1: Збір вимог та обмежень**
З'ясуй у користувача (через аналіз контексту або додаткові питання):
1. **Масштаб:** Це локальний граф пам'яті (як Grynya) чи production система?
2. **Структура знань:** Що є "Сутностями" проєкту у цьому контексті?
3. **Обмеження:** Чи потрібна підтримка векторного пошуку? Наскільки критична хронологія дій?

**КРОК 2: Вибір та визначення стеку технологій**
Спираючись на [Технологічний Стек Grynya](resources/grynya-stack.md) (або на загальні ресурси, якщо користувач проєктує іншу систему):
- Окресли архітектуру зберігання даних (FalkorDB/Neo4j).
- Запропонуй метод оркестрації (MCP Bridge / custom python script / LangChain).
- Проаналізуй "за" та "проти" обраних рішень.

**КРОК 3: Проєктування Схеми та Патернів**
Критично важливий крок:
1. Застосуй патерн **Activity-Centric Memory Agent**, використовуючи [Патерни Графа Grynya](resources/grynya-patterns.md).
2. Зауваж на Правилі Тріади (Node Triad): кожна транзакція створює щонайменше `Request/Feedback` + `Response` + `Analysis`.
3. Визнач типи сутностей (`:Entity`) та стратегію їх зв'язування (`[:INVOLVES]`, `[:MENTIONS]`).

**КРОК 4: Інтеграція / Deployment Strategies**
Спроєктуй, як агент (LLM) буде отримувати доступ до графа:
- Чи потрібна генерація Cypher-запитів на льоту (Text-to-Cypher)?
- Як уникнути дублювання сутностей (Entity Resolution)?
- Чи потрібні багатоетапні агенти для обробки?

**КРОК 5: Документування Рішення (Architecture Review)**
Згенеруй архітектурний документ, що структурує всі прийняті рішення (див. шаблон нижче).

---

## Формат виводу

Коли тебе просять спроєктувати або описати GraphRAG-патерн, використовуй такий шаблон:

```markdown
# Архітектура GraphRAG: [Назва Проєкту / Домену]

## 1. Executive Summary
[Опис системи, її цілі та основний доменний патерн (наприклад, Activity-Centric Memory Agent), 2-3 речення.]

## 2. Схема Графа (Graph Schema)
**Ключові вузли (Nodes):**
- `:Session` (Властивості: id, topic, status)
- `:Request` / `:Response` / `:Analysis`
- `:Entity` (Властивості: id, name, type)

**Ключові зв'язки (Relationships):**
- Хронологія: `[:NEXT]`, `[:LAST_EVENT]`
- Структура: `[:PART_OF]`, `[:ANALYZES]`
- Сутності: `[:INVOLVES]`, `[:MENTIONS]`

## 3. Технологічний Стек (Tech Stack)
- **База знань (Graph DB):** [Наприклад, FalkorDB]
- **Векторний пошук:** [Якщо є / Planned]
- **Оркестрація:** [Наприклад, MCP Memory Bridge]
- **LLM / Агент:** [Опис ролі LLM]

## 4. Ключові Архітектурні Рішення та Патерни
- **[Рішення 1. Наприклад: Правило Тріади]:** [Чому це важливо, які ризики знімає]
- **[Рішення 2. Наприклад: Entity Resolution]:** [Як агент боротиметься з дублюванням]

## 5. Обмеження та Майбутній Розвиток
[Що система поки НЕ вміє. Наприклад: Відсутність векторного пошуку, відсутність інструментів візуальної аналітики. План покращення.]
```

## Інтеграція з Memory Manager
`graphrag-system-design` працює у синергії з `memory-manager`. При внесенні архітектурних змін (напр., додавання нового типу вузла або атрибуту схеми) переконайся, що ці зміни не порушують існуючих протоколів (`protocols/protocol_db.md`, `sa.md`, `ss.md`). Всі архітектурні рішення СЛІД записати у граф за допомогою `/sa` команди.
